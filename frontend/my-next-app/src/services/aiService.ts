"use client";

/* ============================================================
   AI SERVICE — Voice Command → Backend → Structured Response
   ============================================================
   All fetch calls go through this module.
   Backend base URL is read from env; falls back to localhost.
   ============================================================ */

const API_BASE =
  process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:8000";

/* ============================================================
   REQUEST / RESPONSE TYPES
   ============================================================ */

export type CommandIntent =
  | "generate"    // write new code
  | "refactor"    // rewrite existing code
  | "explain"     // explain selected code
  | "fix"         // fix a bug
  | "test"        // generate tests
  | "document"    // add docs/comments
  | "unknown";    // fallback

export interface VoiceCommandRequest {
  transcript: string;
  context: EditorContext;
}

export interface EditorContext {
  language: string;
  filename: string;
  currentCode: string;
  selectedText?: string;
  cursorLine?: number;
}

export interface AICommandResponse {
  intent: CommandIntent;
  code: string | null;
  explanation: string;
  insertMode: "replace" | "append" | "cursor" | "none";
  targetLine?: number;
  error?: string;
}

/* ============================================================
   INTENT ROUTER (client-side keyword sniff as fallback)
   Used when backend is unreachable to provide best-effort
   local classification before retrying.
   ============================================================ */
const INTENT_PATTERNS: Array<{ pattern: RegExp; intent: CommandIntent }> = [
  { pattern: /\b(write|create|generate|add|build|make)\b/i,          intent: "generate"  },
  { pattern: /\b(refactor|rewrite|clean|improve|optimize|rename)\b/i, intent: "refactor"  },
  { pattern: /\b(explain|what does|what is|describe|tell me)\b/i,     intent: "explain"   },
  { pattern: /\b(fix|debug|error|bug|broken|issue|wrong)\b/i,         intent: "fix"       },
  { pattern: /\b(test|spec|unit test|jest|vitest)\b/i,                intent: "test"      },
  { pattern: /\b(document|comment|jsdoc|docstring)\b/i,               intent: "document"  },
];

export function classifyIntent(transcript: string): CommandIntent {
  for (const { pattern, intent } of INTENT_PATTERNS) {
    if (pattern.test(transcript)) return intent;
  }
  return "unknown";
}

/* ============================================================
   MAIN API CALL
   ============================================================ */
export async function sendVoiceCommand(
  request: VoiceCommandRequest,
  signal?: AbortSignal
): Promise<AICommandResponse> {
  const response = await fetch(`${API_BASE}/api/voice/command`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
    },
    body: JSON.stringify(request),
    signal,
  });

  if (!response.ok) {
    let detail = `HTTP ${response.status}`;
    try {
      const err = await response.json();
      detail = err?.detail ?? err?.message ?? detail;
    } catch (_) { /* ignore parse error */ }
    throw new Error(detail);
  }

  const data: AICommandResponse = await response.json();

  /* Validate that the backend returned required fields */
  if (typeof data.code === "undefined" || typeof data.explanation === "undefined") {
    throw new Error("Invalid response format from backend.");
  }

  return data;
}

/* ============================================================
   MOCK RESPONSE — used when backend is not yet connected.
   Provides realistic structured output for every intent so the
   UI flow can be demonstrated end-to-end without a server.
   ============================================================ */
const MOCK_RESPONSES: Record<CommandIntent, (req: VoiceCommandRequest) => AICommandResponse> = {
  generate: (req) => ({
    intent: "generate",
    insertMode: "append",
    explanation: `Generated code based on: "${req.transcript}"`,
    code: `// Generated by VoiceIDE — "${req.transcript}"
async function generatedFunction() {
  // TODO: implement logic
  return null;
}`,
  }),
  refactor: (req) => ({
    intent: "refactor",
    insertMode: "replace",
    explanation: `Refactored the current selection based on: "${req.transcript}"`,
    code: `// Refactored by VoiceIDE
${req.context.selectedText
  ? req.context.selectedText
      .split("\n")
      .map((l) => l.trimEnd())
      .join("\n")
  : "// (no selection — refactored full file)"}`,
  }),
  explain: (req) => ({
    intent: "explain",
    insertMode: "none",
    explanation: `This code in ${req.context.filename} appears to handle core functionality. The selected snippet performs operations relevant to the application's data flow. Voice command received: "${req.transcript}"`,
    code: null,
  }),
  fix: (req) => ({
    intent: "fix",
    insertMode: "replace",
    explanation: `Fixed potential issues based on: "${req.transcript}"`,
    code: `// Fixed by VoiceIDE
${req.context.selectedText ?? req.context.currentCode.slice(0, 200)}
// ↑ Applied fix: added null checks and error handling`,
  }),
  test: (req) => ({
    intent: "test",
    insertMode: "append",
    explanation: `Generated tests for ${req.context.filename}`,
    code: `// Tests generated by VoiceIDE — "${req.transcript}"
describe('${req.context.filename.replace(/\.[^.]+$/, "")}', () => {
  it('should work correctly', () => {
    expect(true).toBe(true);
  });

  it('handles edge cases', () => {
    expect(null).toBeNull();
  });
});`,
  }),
  document: (req) => ({
    intent: "document",
    insertMode: "append",
    explanation: `Added documentation for ${req.context.filename}`,
    code: `/**
 * @fileoverview ${req.context.filename}
 * @description Auto-documented by VoiceIDE
 * Voice command: "${req.transcript}"
 *
 * @module ${req.context.filename.replace(/\.[^.]+$/, "")}
 */`,
  }),
  unknown: (req) => ({
    intent: "unknown",
    insertMode: "append",
    explanation: `I heard: "${req.transcript}". Could you be more specific? Try: "generate a function that...", "refactor this to use...", or "explain this code".`,
    code: `// VoiceIDE: command "${req.transcript}" — unclear intent
// Try: generate / refactor / explain / fix / test / document`,
  }),
};

export async function sendVoiceCommandWithFallback(
  request: VoiceCommandRequest,
  signal?: AbortSignal
): Promise<AICommandResponse & { usedMock?: boolean }> {
  try {
    const result = await sendVoiceCommand(request, signal);
    return result;
  } catch (err) {
    /* Network error or backend not running → use mock */
    if (err instanceof Error && err.name === "AbortError") throw err;

    const intent = classifyIntent(request.transcript);
    const mockFn = MOCK_RESPONSES[intent];
    return { ...mockFn(request), usedMock: true };
  }
}
