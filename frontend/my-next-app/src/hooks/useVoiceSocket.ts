"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import { EditorContext, classifyIntent } from "../services/aiService";

/* ============================================================
   TYPES
   ============================================================ */
export type WSStatus = "connecting" | "connected" | "disconnected" | "error";

export interface WSResponse {
  type: "response";
  intent: string;
  code: string | null;
  explanation: string;
  insertMode: string;
  targetLine?: number;
  openFile?: string | null;
}
export interface WSError { type: "error"; message: string; }
interface WSThinking    { type: "thinking"; }
type WSIncoming = WSThinking | WSResponse | WSError;

export type ResponseHandler = (msg: WSResponse | WSError) => void;

export interface UseVoiceSocketReturn {
  status: WSStatus;
  isThinking: boolean;
  sendCommand: (transcript: string, context: EditorContext) => void;
  onResponse: (cb: ResponseHandler) => () => void;
}

/* ============================================================
   MOCK fallback (when backend is unreachable)
   ============================================================ */
function buildMock(transcript: string, ctx: EditorContext): WSResponse {
  const fm = transcript.match(/\b([\w\-/]+\.(ts|tsx|js|jsx|py|css|json|md))\b/i);
  const isOpenFile = /\b(open|show|navigate to|go to|switch to)\b/i.test(transcript) && !!fm;
  const intent: string = isOpenFile ? "open_file" : classifyIntent(transcript);

  const expl: Record<string, string> = {
    generate:  "Generated code based on: " + transcript,
    refactor:  "Refactored code in " + ctx.filename + ".",
    explain:   "This file, " + ctx.filename + ", handles core application logic.",
    fix:       "Fixed the issue: " + transcript,
    test:      "Generated unit tests for " + ctx.filename + ".",
    document:  "Added documentation to " + ctx.filename + ".",
    open_file: "Opening " + (fm?.[1] ?? "the requested file") + ".",
    unknown:   'I heard: "' + transcript + '". Please be more specific. Try: generate, refactor, explain, fix, test, or document.',
  };

  const codeMap: Record<string, string | null> = {
    generate:  "// Generated by VoiceIDE\nasync function generatedFunction() {\n  return null;\n}",
    refactor:  "// Refactored by VoiceIDE\n" + (ctx.selection ?? ctx.currentCode).slice(0, 300),
    explain:   null,
    fix:       "// Fixed by VoiceIDE\n" + (ctx.selection ?? ctx.currentCode).slice(0, 300),
    test:      "describe('" + ctx.filename + "', () => {\n  it('should work', () => {\n    expect(true).toBe(true);\n  });\n});",
    document:  "/**\n * @fileoverview " + ctx.filename + "\n * @description Auto-documented by VoiceIDE\n */",
    open_file: null,
    unknown:   null,
  };

  const modeMap: Record<string, string> = {
    generate: "append", refactor: "replace", explain: "none",
    fix: "replace", test: "append", document: "append",
    open_file: "none", unknown: "none",
  };

  return {
    type: "response",
    intent,
    explanation: expl[intent] ?? expl.unknown,
    code: codeMap[intent] ?? null,
    insertMode: modeMap[intent] ?? "none",
    openFile: intent === "open_file" ? (fm?.[1] ?? null) : null,
  };
}

/* ============================================================
   CONSTANTS
   ============================================================ */
const WS_ENDPOINT =
  typeof window !== "undefined"
    ? (process.env.NEXT_PUBLIC_WS_URL ?? "ws://localhost:8000/ws/voice")
    : "ws://localhost:8000/ws/voice";

const RECONNECT_DELAY_MS = 2500;
const MAX_RECONNECTS     = 5;

/* ============================================================
   HOOK
   ============================================================ */
export function useVoiceSocket(): UseVoiceSocketReturn {
  const [status, setStatus]       = useState<WSStatus>("disconnected");
  const [isThinking, setThinking] = useState(false);

  const wsRef          = useRef<WebSocket | null>(null);
  const handlersRef    = useRef<Set<ResponseHandler>>(new Set());
  const reconnectCount = useRef(0);
  const reconnTimer    = useRef<ReturnType<typeof setTimeout> | null>(null);
  const mountedRef     = useRef(true);

  const dispatch = useCallback((msg: WSResponse | WSError) => {
    handlersRef.current.forEach(cb => cb(msg));
  }, []);

  const connect = useCallback(() => {
    if (typeof window === "undefined") return;
    if (wsRef.current?.readyState === WebSocket.OPEN) return;

    try {
      const ws = new WebSocket(WS_ENDPOINT);
      wsRef.current = ws;
      if (mountedRef.current) setStatus("connecting");

      ws.onopen = () => {
        if (!mountedRef.current) return;
        setStatus("connected");
        reconnectCount.current = 0;
      };

      ws.onmessage = (ev) => {
        if (!mountedRef.current) return;
        let msg: WSIncoming;
        try { msg = JSON.parse(ev.data as string); }
        catch { return; }

        if (msg.type === "thinking") { setThinking(true); return; }
        setThinking(false);
        if (msg.type === "response" || msg.type === "error") dispatch(msg);
      };

      ws.onerror = () => {
        if (!mountedRef.current) return;
        setStatus("error");
      };

      ws.onclose = () => {
        if (!mountedRef.current) return;
        setStatus("disconnected");
        setThinking(false);
        wsRef.current = null;
        if (reconnectCount.current < MAX_RECONNECTS) {
          reconnectCount.current += 1;
          reconnTimer.current = setTimeout(connect, RECONNECT_DELAY_MS);
        }
      };
    } catch {
      if (mountedRef.current) setStatus("error");
    }
  }, [dispatch]);

  /* Connect on mount, disconnect on unmount */
  useEffect(() => {
    mountedRef.current = true;
    connect();
    return () => {
      mountedRef.current = false;
      if (reconnTimer.current) clearTimeout(reconnTimer.current);
      wsRef.current?.close();
    };
  }, [connect]);

  /* ── Send a command ── */
  const sendCommand = useCallback((transcript: string, context: EditorContext) => {
    const payload = JSON.stringify({ type: "command", transcript, context });

    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(payload);
    } else {
      /* Backend unreachable — use mock with a short delay to feel async */
      setThinking(true);
      setTimeout(() => {
        setThinking(false);
        dispatch(buildMock(transcript, context));
      }, 700);
    }
  }, [dispatch]);

  /* ── Register a response handler, returns unsubscribe fn ── */
  const onResponse = useCallback((cb: ResponseHandler): (() => void) => {
    handlersRef.current.add(cb);
    return () => { handlersRef.current.delete(cb); };
  }, []);

  return { status, isThinking, sendCommand, onResponse };
}
